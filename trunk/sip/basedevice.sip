// basedevice.sip generated by MetaSIP on Fri Feb  1 22:38:24 2013
//
// This file is part of the PyIndi Python extension module.
//
// PyIndi: Python binding to the Indi Library    
// Copyright (c) 2012 Geehalel  <geehalel@gmail.com>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


namespace INDI
{
%TypeHeaderCode
#include <basedevice.h>
%End

    class BaseDevice
    {
%TypeHeaderCode
#include <basedevice.h>
%End

    public:
        BaseDevice();
        ~BaseDevice();

        enum INDI_ERROR
        {
            INDI_DEVICE_NOT_FOUND,
            INDI_PROPERTY_INVALID,
            INDI_PROPERTY_DUPLICATED,
            INDI_DISPATCH_ERROR,
        };

        INumberVectorProperty *getNumber(const char *name);
        ITextVectorProperty *getText(const char *name);
        ISwitchVectorProperty *getSwitch(const char *name);
        ILightVectorProperty *getLight(const char *name);
        IBLOBVectorProperty *getBLOB(const char *name);
        int removeProperty(const char *name, char *errmsg);
        void registerProperty(void *p, INDI_TYPE type);
        void *getRawProperty(const char *name, INDI_TYPE type = INDI_UNKNOWN);
        INDI::Property *getProperty(const char *name, INDI_TYPE type = INDI_UNKNOWN);
        bool isConnected();
        void setDeviceName(const char *dev);
        const char *getDeviceName();
        void addMessage(const char *msg);
        const char *messageQueue(int index);
        const char *lastMessage();
        void setMediator(INDI::BaseMediator *med);
        INDI::BaseMediator *getMediator();
        SIP_PYLIST getProperties();
%MethodCode
            PyObject *l;
                std::vector<INDI::Property*, std::allocator<INDI::Property*> > *r;
                r=sipCpp->getProperties();
                
                // Create the Python list of the correct length.
                if ((l = PyList_New(r -> size())) == NULL)
                    return NULL;
            
                // Go through each element in the C++ instance and convert it to a
                // wrapped P2d.
                for (int i = 0; i < (int)(r -> size()); ++i)
                {
                    //INDI::Property *cpp = new INDI::Property(r -> at(i));
                    INDI::Property *cpp = r -> at(i);
                    PyObject *pobj;
            
                    // Get the Python wrapper for the Type instance, creating a new
                    // one if necessary, and handle any ownership transfer.
                    if ((pobj = sipConvertFromType(cpp, 
                        sipType_INDI_Property, 
                        NULL)) == NULL)
                    {
                        // There was an error so garbage collect the Python list.
                        Py_DECREF(l);
                        return NULL;
                    }
            
                    // Add the wrapper to the list.
                    PyList_SET_ITEM(l, i, pobj);
                }
            
                // Return the Python list.
                return l;
%End

        const char *getDriverName();
        const char *getDriverExec();

    private:
        INDI::BaseDevice &operator=(const INDI::BaseDevice &);
    };
};

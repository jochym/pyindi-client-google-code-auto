// baseclient.sip generated by MetaSIP on Fri Feb  1 22:38:24 2013
//
// This file is part of the PyIndi Python extension module.
//
// PyIndi: Python binding to the Indi Library    
// Copyright (c) 2012 Geehalel  <geehalel@gmail.com>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


namespace INDI
{
%TypeHeaderCode
#include <baseclient.h>
%End

    class BaseClient : INDI::BaseMediator
    {
%TypeHeaderCode
#include <baseclient.h>
%End

    public:
        enum
        {
            INDI_DEVICE_NOT_FOUND,
            INDI_PROPERTY_INVALID,
            INDI_PROPERTY_DUPLICATED,
            INDI_DISPATCH_ERROR,
        };

        BaseClient();
        void setServer(const char *hostname, unsigned int port);
        void watchDevice(const char *deviceName);
        bool disconnectServer() /ReleaseGIL/;
        void connectDevice(const char *deviceName);
        void disconnectDevice(const char *deviceName);
        INDI::BaseDevice *getDevice(const char *deviceName);
        SIP_PYLIST getDevices() const;
%MethodCode
            PyObject *l;
                const std::vector<INDI::BaseDevice*, std::allocator<INDI::BaseDevice*> > *r;
                r=&(sipCpp->getDevices());
                
                // Create the Python list of the correct length.
                if ((l = PyList_New(r->size())) == NULL)
                    return NULL;
            
                // Go through each element in the C++ instance and convert it to a
                // wrapped P2d.
                for (int i = 0; i < (int)(r->size()); ++i)
                {
                    //INDI::Property *cpp = new INDI::Property(r -> at(i));
                    INDI::BaseDevice *cpp = r->at(i);
                    PyObject *pobj;
            
                    // Get the Python wrapper for the Type instance, creating a new
                    // one if necessary, and handle any ownership transfer.
                    if ((pobj = sipConvertFromType(cpp, 
                        sipType_INDI_BaseDevice, 
                        NULL)) == NULL)
                    {
                        // There was an error so garbage collect the Python list.
                        Py_DECREF(l);
                        return NULL;
                    }
            
                    // Add the wrapper to the list.
                    PyList_SET_ITEM(l, i, pobj);
                }
            
                // Return the Python list.
                return l;
%End

        void setBLOBMode(BLOBHandling blobH, const char *dev, const char *prop = 0);
        static void *listenHelper(void *context);
        const char *getHost();
        int getPort();
        void sendNewText(ITextVectorProperty *pp);
        void sendNewText(const char *deviceName, const char *propertyName, const char *elementName, const char *text);
        void sendNewNumber(INumberVectorProperty *pp);
        void sendNewNumber(const char *deviceName, const char *propertyName, const char *elementName, double value);
        void sendNewSwitch(ISwitchVectorProperty *pp);
        void sendNewSwitch(const char *deviceName, const char *propertyName, const char *elementName);
        void startBlob(const char *devName, const char *propName, const char *timestamp);
        void sendOneBlob(const char *blobName, unsigned int blobSize, const char *blobFormat, void *blobBuffer);
        void finishBlob();

    protected:
        int removeDevice(const char *devName, char *errmsg);
        INDI::BaseDevice *findDev(const char *devName, char *errmsg);

    private:
        void setDriverConnection(bool status, const char *deviceName);

    public:
        virtual ~BaseClient();
        bool connectServer() /ReleaseGIL/;

    private:
        void listenINDI() /ReleaseGIL/;
        INDI::BaseClient &operator=(const INDI::BaseClient &);
    };
};

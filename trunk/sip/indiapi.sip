// indiapi.sip generated by MetaSIP on Fri Feb  1 22:38:24 2013
//
// This file is part of the PyIndi Python extension module.
//
// PyIndi: Python binding to the Indi Library    
// Copyright (c) 2012 Geehalel  <geehalel@gmail.com>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


%ModuleCode
#include <indiapi.h>
%End

enum ISState
{
    ISS_OFF,
    ISS_ON,
};

enum IPState
{
    IPS_IDLE,
    IPS_OK,
    IPS_BUSY,
    IPS_ALERT,
};

enum ISRule
{
    ISR_1OFMANY,
    ISR_ATMOST1,
    ISR_NOFMANY,
};

enum IPerm
{
    IP_RO,
    IP_WO,
    IP_RW,
};

struct IText
{
%TypeHeaderCode
#include <indiapi.h>
%End

    char *name {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->name, sipVal, 32);
            sipCpp->name[31]='\0';
%End

    };
    char *label {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->label, sipVal, 32);
            sipCpp->label[31]='\0';
%End

    };
    char *text;
    _ITextVectorProperty *tvp;
    void *aux0;
    void *aux1;
};

struct _ITextVectorProperty
{
%TypeHeaderCode
#include <indiapi.h>
%End

    char *device {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->device, sipVal, 32);
            sipCpp->device[31]='\0';
%End

    };
    char *name {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->name, sipVal, 32);
            sipCpp->name[31]='\0';
%End

    };
    char *label {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->label, sipVal, 32);
            sipCpp->label[31]='\0';
%End

    };
    char *group {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->group, sipVal, 32);
            sipCpp->group[31]='\0';
%End

    };
    IPerm p;
    double timeout;
    IPState s;
    IText *tp {
%GetCode
        PyObject *l;
        
             // Create the Python list of the correct length.
             if ((l = PyList_New(sipCpp -> ntp)) == NULL)
                 return NULL;
        
             // Go through each element in the C++ instance and convert it to a
            // wrapped object.
            for (int i = 0; i <(int)sipCpp -> ntp; ++i)
            {
               // Add the wrapper to the list.
                PyList_SET_ITEM(l, i, sipConvertFromType(&(sipCpp -> tp[i]), sipType_IText,NULL));
            }
        
            // Return the Python list.
            sipPy=l;
%End

%SetCode
        PyObject *iterator = PyObject_GetIter(sipPy);
            PyObject *item;
            int i=0;
             if (sipCpp->tp) free(sipCpp->tp);
             sipCpp->tp=(IText *)malloc(PyList_GET_SIZE(sipPy)*sizeof(IText));
        
             while ((item = PyIter_Next(iterator)))
             {
                 sipCpp->tp[i++]=*((IText *)sipConvertToType(item, sipType_IText, NULL, 0, NULL, NULL));
                 Py_DECREF(item);
             }
        
             Py_DECREF(iterator);
%End

    };
    int ntp;
    char *timestamp {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->timestamp, sipVal, 32);
            sipCpp->timestamp[31]='\0';
%End

    };
    void *aux;
};

typedef _ITextVectorProperty ITextVectorProperty;

struct INumber
{
%TypeHeaderCode
#include <indiapi.h>
%End

    char *name {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->name, sipVal, 32);
            sipCpp->name[31]='\0';
%End

    };
    char *label {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->label, sipVal, 32);
            sipCpp->label[31]='\0';
%End

    };
    char *format {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->format, sipVal, 32);
            sipCpp->format[31]='\0';
%End

    };
    double min;
    double max;
    double step;
    double value;
    _INumberVectorProperty *nvp;
    void *aux0;
    void *aux1;
};

struct _INumberVectorProperty
{
%TypeHeaderCode
#include <indiapi.h>
%End

    char *device {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->device, sipVal, 32);
            sipCpp->device[31]='\0';
%End

    };
    char *name {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->name, sipVal, 32);
            sipCpp->name[31]='\0';
%End

    };
    char *label {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->label, sipVal, 32);
            sipCpp->label[31]='\0';
%End

    };
    char *group {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->group, sipVal, 32);
            sipCpp->group[31]='\0';
%End

    };
    IPerm p;
    double timeout;
    IPState s;
    INumber *np {
%GetCode
        PyObject *l;
        
             // Create the Python list of the correct length.
             if ((l = PyList_New(sipCpp -> nnp)) == NULL)
                 return NULL;
        
             // Go through each element in the C++ instance and convert it to a
            // wrapped object.
            for (int i = 0; i <(int)sipCpp -> nnp; ++i)
            {
               // Add the wrapper to the list.
                PyList_SET_ITEM(l, i, sipConvertFromType(&(sipCpp -> np[i]), sipType_INumber,NULL));
            }
        
            // Return the Python list.
            sipPy=l;
%End

%SetCode
        PyObject *iterator = PyObject_GetIter(sipPy);
            PyObject *item;
            int i=0;
             if (sipCpp->np) free(sipCpp->np);
             sipCpp->np=(INumber *)malloc(PyList_GET_SIZE(sipPy)*sizeof(INumber));
        
             while ((item = PyIter_Next(iterator)))
             {
                 sipCpp->np[i++]=*((INumber *)sipConvertToType(item, sipType_INumber, NULL, 0, NULL, NULL));
                 Py_DECREF(item);
             }
        
             Py_DECREF(iterator);
%End

    };
    int nnp;
    char *timestamp {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->timestamp, sipVal, 32);
            sipCpp->timestamp[31]='\0';
%End

    };
    void *aux;
};

typedef _INumberVectorProperty INumberVectorProperty;

struct ISwitch
{
%TypeHeaderCode
#include <indiapi.h>
%End

    char *name {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->name, sipVal, 32);
            sipCpp->name[31]='\0';
%End

    };
    char *label {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->label, sipVal, 32);
            sipCpp->label[31]='\0';
%End

    };
    ISState s;
    _ISwitchVectorProperty *svp;
    void *aux;
};

struct _ISwitchVectorProperty
{
%TypeHeaderCode
#include <indiapi.h>
%End

    char *device {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->device, sipVal, 32);
            sipCpp->device[31]='\0';
%End

    };
    char *name {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->name, sipVal, 32);
            sipCpp->name[31]='\0';
%End

    };
    char *label {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->label, sipVal, 32);
            sipCpp->label[31]='\0';
%End

    };
    char *group {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->group, sipVal, 32);
            sipCpp->group[31]='\0';
%End

    };
    IPerm p;
    ISRule r;
    double timeout;
    IPState s;
    ISwitch *sp {
%GetCode
        PyObject *l;
        
             // Create the Python list of the correct length.
             if ((l = PyList_New(sipCpp -> nsp)) == NULL)
                 return NULL;
        
             // Go through each element in the C++ instance and convert it to a
            // wrapped object.
            for (int i = 0; i <(int)sipCpp -> nsp; ++i)
            {
               // Add the wrapper to the list.
                PyList_SET_ITEM(l, i, sipConvertFromType(&(sipCpp -> sp[i]), sipType_ISwitch,NULL));
            }
        
            // Return the Python list.
            sipPy=l;
%End

%SetCode
        PyObject *iterator = PyObject_GetIter(sipPy);
            PyObject *item;
            int i=0;
             if (sipCpp->sp) free(sipCpp->sp);
             sipCpp->sp=(ISwitch *)malloc(PyList_GET_SIZE(sipPy)*sizeof(ISwitch));
        
             while ((item = PyIter_Next(iterator)))
             {
                 sipCpp->sp[i++]=*((ISwitch *)sipConvertToType(item, sipType_ISwitch, NULL, 0, NULL, NULL));
                 Py_DECREF(item);
             }
        
             Py_DECREF(iterator);
%End

    };
    int nsp;
    char *timestamp {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->timestamp, sipVal, 32);
            sipCpp->timestamp[31]='\0';
%End

    };
    void *aux;
};

typedef _ISwitchVectorProperty ISwitchVectorProperty;

struct ILight
{
%TypeHeaderCode
#include <indiapi.h>
%End

    char *name {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->name, sipVal, 32);
            sipCpp->name[31]='\0';
%End

    };
    char *label {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->label, sipVal, 32);
            sipCpp->label[31]='\0';
%End

    };
    IPState s;
    _ILightVectorProperty *lvp;
    void *aux;
};

struct _ILightVectorProperty
{
%TypeHeaderCode
#include <indiapi.h>
%End

    char *device {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->device, sipVal, 32);
            sipCpp->device[31]='\0';
%End

    };
    char *name {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->name, sipVal, 32);
            sipCpp->name[31]='\0';
%End

    };
    char *label {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->label, sipVal, 32);
            sipCpp->label[31]='\0';
%End

    };
    char *group {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->group, sipVal, 32);
            sipCpp->group[31]='\0';
%End

    };
    IPState s;
    ILight *lp {
%GetCode
        PyObject *l;
        
             // Create the Python list of the correct length.
             if ((l = PyList_New(sipCpp -> nlp)) == NULL)
                 return NULL;
        
             // Go through each element in the C++ instance and convert it to a
            // wrapped object.
            for (int i = 0; i <(int)sipCpp -> nlp; ++i)
            {
               // Add the wrapper to the list.
                PyList_SET_ITEM(l, i, sipConvertFromType(&(sipCpp -> lp[i]), sipType_ILight,NULL));
            }
        
            // Return the Python list.
            sipPy=l;
%End

%SetCode
        PyObject *iterator = PyObject_GetIter(sipPy);
            PyObject *item;
            int i=0;
             if (sipCpp->lp) free(sipCpp->lp);
             sipCpp->lp=(ILight *)malloc(PyList_GET_SIZE(sipPy)*sizeof(ILight));
        
             while ((item = PyIter_Next(iterator)))
             {
                 sipCpp->lp[i++]=*((ILight *)sipConvertToType(item, sipType_ILight, NULL, 0, NULL, NULL));
                 Py_DECREF(item);
             }
        
             Py_DECREF(iterator);
%End

    };
    int nlp;
    char *timestamp {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->timestamp, sipVal, 32);
            sipCpp->timestamp[31]='\0';
%End

    };
    void *aux;
};

typedef _ILightVectorProperty ILightVectorProperty;

struct IBLOB
{
%TypeHeaderCode
#include <indiapi.h>
%End

    char *name {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->name, sipVal, 32);
            sipCpp->name[31]='\0';
%End

    };
    char *label {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->label, sipVal, 32);
            sipCpp->label[31]='\0';
%End

    };
    char *format {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->format, sipVal, 32);
            sipCpp->format[31]='\0';
%End

    };
    void *blob {
%GetCode
        Py_buffer blobbuffer;
        PyBuffer_FillInfo(&blobbuffer, (PyObject *)sipPy, sipCpp->blob, sipCpp->bloblen, 1, 0);
        sipPy=PyMemoryView_FromBuffer(&blobbuffer);
%End

    };
    int bloblen;
    int size;
    _IBLOBVectorProperty *bvp;
    void *aux0;
    void *aux1;
    void *aux2;
};

struct _IBLOBVectorProperty
{
%TypeHeaderCode
#include <indiapi.h>
%End

    char *device {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->device, sipVal, 32);
            sipCpp->device[31]='\0';
%End

    };
    char *name {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->name, sipVal, 32);
            sipCpp->name[31]='\0';
%End

    };
    char *label {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->label, sipVal, 32);
            sipCpp->label[31]='\0';
%End

    };
    char *group {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->group, sipVal, 32);
            sipCpp->group[31]='\0';
%End

    };
    IPerm p;
    double timeout;
    IPState s;
    IBLOB *bp {
%GetCode
        PyObject *l;
        
             // Create the Python list of the correct length.
             if ((l = PyList_New(sipCpp -> nbp)) == NULL)
                 return NULL;
        
             // Go through each element in the C++ instance and convert it to a
            // wrapped object.
            for (int i = 0; i <(int)sipCpp -> nbp; ++i)
            {
               // Add the wrapper to the list.
                PyList_SET_ITEM(l, i, sipConvertFromType(&(sipCpp -> bp[i]), sipType_IBLOB,NULL));
            }
        
            // Return the Python list.
            sipPy=l;
%End

%SetCode
        PyObject *iterator = PyObject_GetIter(sipPy);
            PyObject *item;
            int i=0;
             if (sipCpp->bp) free(sipCpp->bp);
             sipCpp->bp=(IBLOB *)malloc(PyList_GET_SIZE(sipPy) * sizeof(IBLOB));
        
             while ((item = PyIter_Next(iterator)))
             {
                 sipCpp->bp[i++]=*((IBLOB *)sipConvertToType(item, sipType_IBLOB, NULL, 0, NULL, NULL));
                 Py_DECREF(item);
             }
        
             Py_DECREF(iterator);
%End

    };
    int nbp;
    char *timestamp {
%SetCode
        /* mon code */
           char *sipVal;
            sipVal = (char *)sipString_AsUTF8String(&sipPy);
        
            if (PyErr_Occurred() != NULL)
                return -1;
        
            memcpy(sipCpp->timestamp, sipVal, 32);
            sipCpp->timestamp[31]='\0';
%End

    };
    void *aux;
};

typedef _IBLOBVectorProperty IBLOBVectorProperty;
